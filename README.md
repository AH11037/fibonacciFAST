# Fibonacci N<sup>th</sup> Term Finder - FAST edition

![C++](https://img.shields.io/badge/C%2B%2B-17-blue)
![Time Complexity](https://img.shields.io/badge/Time%20Complexity-O(log%20n)-green)
![Boost](https://img.shields.io/badge/Boost-header--only-orange)
![Platform](https://img.shields.io/badge/Platform-Windows-lightgrey)

Did you think the other Fibonacci program was slow?<br> 
Did you want a faster n<sup>th</sup> term finder?<br>
Have you or anyone you know been in an accident that wasn't your fault?<br>
If the answer to any of these questions was **YES**, this program can fix it.

This is a harder, better, faster & stronger version of my original Fibonacci program. This version computes the N<sup>th</sup> using matrix exponentiation, allowing it to scale to massive values of `n` while still supporting massive results via `boost::multiprecision::cpp_int`.
## Screenshot
<img width="1894" height="410" alt="image" src="https://github.com/user-attachments/assets/8d3f0a02-d94d-4386-96c0-61ea6f2d4e7b" /> <br>
In this example, I calculated the 10,000<sup>th</sup> term in a ludicrous amount of time.
## Downloading & Running
1. Download the most recent `.exe` from `Releases`
2. Double-click to run it
3. Enter an integer (`n`) when prompted
4. Choose how you want the result displayed:
   * Printed in the terminal
   * Saved to `fibonacci.txt` (a separate txt file that gets autogenerated when needed)
5. Receive:
   * The `n`<sup>th</sup> Fibonacci number
   * The time taken to compute it (in microseconds and seconds)
## How It Works
This program uses matrix exponentiation, based on the calculation:
```math
\begin{bmatrix}
1 & 1\\
1 & 0
\end{bmatrix}^n =
\begin{bmatrix}
F(n + 1) & F(n)\\
F(n) & F(n - 1)
\end{bmatrix}
```
Matrix exponentiation allows Fibonacci numbers to be computed in logarithmic time by repeatedly squaring a fixed 2x2 matrix instead of calculating each term one-by-one.
### Key details:
* Fibonacci numbers are calculated using binary exponentiation
* Runtime complexity is O(log n) instead of O(n)
* All arithmetic uses `boost::multiprecision::cpp_int`, allowing:
  * Extremely large Fibonacci values
  * No integer overflow
* Matrix multiplication is implemented manually using fixed-size `std::array`
## Features
* Input validation
  * Reject inputs that are non-numeric or negative
* Choice of output:
  * Terminal display
  * `.txt` file output for very large results
* Precise runtime measurement using `std::chrono`
## What I Learned
* Matrix exponentiation and fast Fibonacci algorithms
* Binary exponentiation for logarithmic-time performance
* Using `boost::multiprecision::cpp_int` for arbitrary-precision arithmetic
* Clean separation of concerns (input, computation, output)
* Measuring performance meaningfully
## Limitations
* Requires `Boost` to be installed if building from source
  * Not required to run the precompiled `.exe`
* Output numbers can be $${\color{red}ENORMOUS}$$
  * Printing to terminal may be slow
  * Writing to a file is recommended for very large `n`
* Still bound by available memory for extremely large results
## Related Projects
* Original slow version (<a href = "https://github.com/AH11037/fibonacciNthTermFinder">string-based Fibonacci</a>)
## Future Improvements
* Remove Boost dependency by implementing a custom BigInt
* Improve algorithm even further
* Improve output formatting for extremely large values
* <del>Add input error handling</del>
